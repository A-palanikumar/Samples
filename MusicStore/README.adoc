= Steeltoe MusicStore Sample Application
:toc: preamble
:toclevels: 1
:!toc-title:
:linkattrs:

Sample app illustrating how to use all of the Steeltoe components together in a ASP.NET Core application. This application is based on the ASP.NET Core reference app https://github.com/aspnet/MusicStore[MusicStore, window="_blank"] provided by Microsoft.

== About

In creating this application, we took the Microsoft reference application and broke it up into multiple independent services:

* MusicStoreUI - provides the UI to the MusicStore application and all of its services
* MusicStoreService - provides a RESTful API to the MusicStore and its backend Music database
* OrderService - provides a RESTful API for Order processing service and its backend Order database
* ShoppingCartService - provides a RESTful api to a ShoppingCart service and its backend ShoppingCart database

[NOTE]
The OrderService and ShoppingCartService are independent from the Music application and could be used in any other application requiring those basic services.

This application makes use of the following Steeltoe components:

* Spring Cloud Config Server Client for centralized application configuration
* Spring Cloud Eureka Server Client for service discovery
* Steeltoe Connector for connecting to MySql using EFCore
* Steeltoe CircuitBreaker to help prevent cascading failures from lower level service failures
* Steeltoe Management for enabling management actuator endpoints that can be used by the Pivotal Apps Manager
* Optionally, uses Steeltoe Redis Connector to connect to a Redis cache for Session storage. This is required if you want to scale the MusicStoreUI component to multiple instances.
* Optionally, uses Steeltoe Redis DataProtection provider to the cause the DataProtection KeyRing to be stored in a Redis cache. This is also required if you want to scale the MusicStoreUI component to multiple instances.
* Optionally, uses Hystrix Dashboard for monitoring Circuit Breakers

The default is not to use a Redis cache for Session storage or DataProtection KeyRing storage. Details on how to enable it are provided below.

== Prepare

.Clone this repo
----
$ git clone https://github.com/SteeltoeOSS/Samples
$ cd MusicStore
----


== Running (Local)


.Start the Spring Cloud Config Server, Spring Cloud Eureka Server, and MySQL
----
$ runBackendServices
----

.Run the MusicStore components
----
$ runMusicStore
# wait until MusicStore services running
$ runMusicStoreUI
----

If all the services startup cleanly, you should be able to hit: <http://localhost:5555/> to see the Music Store.

== Running (Cloud Foundry)

.Log in to Cloud Foundry
----
$ cf login ...
$ cf target ...   # optional
----

.Start the Spring Cloud Config Server, Spring Cloud Eureka Server, and MySQL
----
$ createCloudFoundryServices
----

This will create all of the services needed by the application.  Specifically, it creates:

* mStoreConfig - Spring Cloud Config Server instance
* mStoreRegistry - Spring Cloud Eureka Server instance
* mStoreAccountsDB - MySql database instance for Users and Roles (Identity)
* mStoreOrdersDB - MySql database instance for Orders
* mStoreCartDB - MySql database instance for ShoppingCarts
* mStoreStoreDB - MySql database instance for MusicStore
* mStoreRedis (optional) - Redis cache instance used by MusicStoreUI for storing Session state

The Spring Cloud Config Server instance created by the above script configures the Config Server instance to use the git repo: <https://github.com/SteeltoeOSS/musicStore-config.git>.  This repo contains the same configuration files as those found in `Samples/MusicStore/config`.

[NOTE]
Redis Cache is required if you want to scale the MusicStoreUI app to multiple instances (e.g. cf scale musicui -i 2+). Redis is not required to scale the other micro-services.

[NOTE]
If you plan on using Redis, set the environment variable `USE_REDIS_CACHE=true` before running the above command.

[NOTE]
MySQL v2 uses different naming conventions by default than v1. If your environment uses MySQL v2, you may need to alter the createCloudFoundryServices script accordingly!

[NOTE]
If you wish to change what github repo the Config server instance uses, you can modify `config-server.json` before using the `createCloudFoundryServices` script above.

Once the services have been created and ready on CloudFoundry (i.e. check via `cf services`) then you can use the provided `push*` commands to startup the individual application services on CloudFoundry.

.Push the MusicStore application services to Cloud Foundry (win10x-64)
----
$ pushMusicStoreService win10-x64 netcoreapp2.0
$ pushOrderService win10-x64 netcoreapp2.0
$ pushShoppingCartService win10-x64 netcoreapp2.0
$ pushMusicStoreUI win10-x64 netcoreapp2.0
----

.Push the MusicStore application services to Cloud Foundry (ubuntu.14.04-x64)
----
$ pushMusicStoreService ubuntu.14.04-x64 netcoreapp2.0
$ pushOrderService ubuntu.14.04-x64 netcoreapp2.0
$ pushShoppingCartService ubuntu.14.04-x64 netcoreapp2.0
$ pushMusicStoreUI ubuntu.14.04-x64 netcoreapp2.0
----

[NOTE]
If you wish to use the Redis cache for storing Session state, you will have to set ENVIRONMENT variable `DefineConstants=USE_REDIS_CACHE` before building and pushing the MusicUI application.

Each of the `push*` scripts `dotnet publish` the MusicStore service targeting the `framework` and `runtime` you specify.  They then push the MusicStore service using the appropriate CloudFoundry manifest found in the projects directory (e.g. `manifest-windows.yml`, `manifest.yml` ).

[NOTE]
====
If you are using self-signed certificates it is possible that you might run into SSL certificate validation issues when pushing these apps. The simplest way to fix this is to disable certificate validation for the Spring Cloud Config Client.  You can do this by editing `appsettings.json` and add `spring:cloud:config:validate_certificates=false`. You will need to do this for each of the applications.
====

Once you have pushed all the applications to Cloud Foundry, if you run `cf a`, you should see the following applications:

* musicui - Music store User Interface
* musicstore - Music store database micro-service
* orderprocessing - Order processing micro-service
* shoppingcart - Shopping cart micro-service

.Sample `cf a` output
```
name              requested state   instances   memory   disk   urls
musicstore        started           1/1         1G       1G     musicstore.apps.testcloud.com
musicui           started           1/1         1G       1G     musicui.apps.testcloud.com
orderprocessing   started           1/1         1G       1G     orderprocessing.apps.testcloud.com
shoppingcart      started           1/1         1G       1G     shoppingcart.apps.testcloud.com
```

== Sample Databases

All MusicStore services (i.e. MusicStoreUI, OrderService, etc.) have their own database instance for persisting data.  When a MusicStore service is started locally, it will always drop and recreate its database upon startup. When a MusicStore service is started on CloudFoundry, only the first instance (i.e. CF_INSTANCE_INDEX=0) will drop and recreate its database.  Note then, the service is not fully ready until the first instance has finished initializing its database, even though other instances are ready.

[NOTE]
_See the Official https://steeltoe.io/docs/steeltoe-configuration[Steeltoe Configuration Documentation] for a more in-depth walkthrough of the samples and more detailed information._
